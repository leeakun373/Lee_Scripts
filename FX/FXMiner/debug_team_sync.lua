-- debug_team_sync.lua
-- 这是一个独立的测试脚本，用于诊断团队同步功能
-- 使用方法：直接在 Reaper Action List 中运行此脚本，观察控制台输出

local function msg(str)
  reaper.ShowConsoleMsg(tostring(str) .. "\n")
end

reaper.ClearConsole()
msg("========== FXMiner Team Sync Diagnostic ==========")
msg("Time: " .. os.date("%Y-%m-%d %H:%M:%S"))

-- 1. 设置路径以便能引用 src 里的模块
-- 获取当前脚本路径
local info = debug.getinfo(1, 'S')
local script_path = info.source:match([[^@?(.*[\/])[^\/]-$]])
if not script_path then script_path = "" end

-- 将 src 目录加入 require 搜索路径
package.path = script_path .. "src/?.lua;" .. package.path

msg("Script Path: " .. script_path)

-- 2. 尝试加载模块
msg("\n[Step 1] Loading Modules...")
local status_cfg, Config = pcall(require, "config")
local status_db, DB = pcall(require, "db.db")

if not status_cfg then 
  msg("❌ ERROR: Could not load 'config.lua'. Check file structure.")
  msg("Details: " .. tostring(Config))
  return 
end
if not status_db then 
  msg("❌ ERROR: Could not load 'db.lua'. Check file structure.")
  msg("Details: " .. tostring(DB))
  return 
end
msg("✅ Modules loaded successfully.")

-- 初始化 DB (传入 config)
local db_instance = DB:new(Config)

-- 3. 检查 Config 配置
msg("\n[Step 2] Checking Config paths...")
local team_path = Config.TEAM_PUBLISH_PATH
local team_db_path = (Config.get_team_db_path and Config.get_team_db_path()) or Config.TEAM_DB_PATH

msg("   -> Config.TEAM_PUBLISH_PATH: " .. tostring(team_path))
msg("   -> Config.TEAM_DB_PATH:      " .. tostring(team_db_path))

if not team_path or team_path == "" then
  msg("❌ FAIL: TEAM_PUBLISH_PATH is empty or nil!")
  return
end
if not team_db_path or team_db_path == "" then
  msg("❌ FAIL: TEAM_DB_PATH is empty or nil!")
  return
end
msg("✅ Config looks valid (variables exist).")

-- 4. 检查物理路径读写权限
msg("\n[Step 3] Testing Write Permissions...")
local test_file = team_path .. "/write_test.tmp"
local f = io.open(test_file, "w")
if f then
  f:write("test")
  f:close()
  os.remove(test_file)
  msg("✅ Write Permission OK: Can write to " .. team_path)
else
  msg("❌ FAIL: Cannot write to " .. team_path)
  msg("   Please check Windows Folder Permissions or path correctness.")
  return
end

-- 5. 测试文件锁机制
msg("\n[Step 4] Testing Lock Mechanism...")
local lock_ok, lock_err = db_instance:acquire_lock(team_path)
if lock_ok then
  msg("✅ Lock Acquired successfully.")
  db_instance:release_lock(team_path)
  msg("✅ Lock Released successfully.")
else
  msg("❌ FAIL: Acquire Lock failed: " .. tostring(lock_err))
  -- 尝试强制解锁
  msg("   Attempting force release...")
  db_instance:release_lock(team_path)
end

-- 6. 测试真实的数据库写入 (Push)
msg("\n[Step 5] Testing Database Push (Mock Data)...")

-- 模拟一条数据
local mock_path = team_path .. "/DEBUG_TEST_FILE.RfxChain"
local mock_meta = {
  name = "DEBUG_ENTRY",
  description = "This is a test entry generated by debug script",
  metadata = {
    Category = "Test",
    Project = "Debug_Project",
    Element = "Code"
  },
  plugins = {"ReaEQ", "ReaComp"}
}

msg("   Pushing entry: " .. mock_meta.name)
local push_ok, push_err = db_instance:push_to_team_locked(
  team_path,
  team_db_path,
  mock_path,
  mock_meta
)

if push_ok then
  msg("✅ SUCCESS: push_to_team_locked returned true.")
  msg("   Check your server_db.json now. You should see 'DEBUG_TEST_FILE'.")
else
  msg("❌ FAIL: Push failed with error: " .. tostring(push_err))
end

msg("\n========== Diagnostic Finished ==========")
